Полезные ссылки: 

- https://deepthought.blog/2018/10/zero-downtime-database-migration/
- https://dzone.com/articles/safe-database-migration-pattern-without-downtime
- https://thorben-janssen.com/update-database-schema-without-downtime/
- https://www.youtube.com/watch?v=ka-PLyjV3AI
- https://www.youtube.com/watch?v=3mj6Ni7sRN4  Примерный алгоритм (на примере переименования колонки).


**Инкрементные изменения схем** (increment-миграции): добавления колонок, увеличение длин колонок, ослабление constraint-ов, 
добавление новых таблиц (проекций, партиций, сегментов), изменения поисковых индексов (добавления, удаления), 
выполнение наших мигрирующих скриптов с инкрементной логикой. Данные миграции НЕ НАРУШАЮТ ОБРАТНОЙ СОВМЕСТИМОСТИ с 
текущей схемой таблиц на релизе.

**Декрементные изменения схем** (decrement-миграции): удаления колонок, таблиц (проекций, партиций, сегментов), 
усиление constraint-ов (добавление not null, unique, primary индексов), уменьшение длин колонок. 

**Обратно-несовместимые изменения**: переименования колонок, нормализация таблиц, перенос таблиц в другие СУБД

Новая ветка release-migrations: содержит в себе все новые миграции, которые ДОЛЖНЫ быть выполнены перед следующим релизом. 
Данные миграции не нарушают обратной совместимости работы текущих выполняемых воркеров на релизе.

При необходимости миграций в задаче, разработчик для ревью готовит несколько мерж-реквестов. 
Ревьюер должен оценивать изменения в схемах и понимать, относятся ли они к декрементным? инкрементным, 
либо обратно-несовместимым миграциям (в таких кейсах реджектим и разбиваем на совместимые миграци.

- основной -  в мастер (в основном мерже также должны быть включены инкрементные миграции)
- в release-migrations - обратно совместимые миграции, которые буду выполнены в следующем релизе

Флоу релиза:
- сначала мержим в релиз ветку release-migrations
 (если там есть изменения). Ждем применения миграций на всех инстансах (сколько нужно)
- Затем стандартно мержим мастер в релиз. Старые процессы буду работать на старом коде, изменения в схеме не нарушают обратной совместимости

Для сложных обратно-несовместимых миграций, их нужно делать на отдельные шаги, которые будут обратно-совместимы.Описание по ссылкам выше
Примерный алгоритм (на примере переименования колонки). https://www.youtube.com/watch?v=3mj6Ni7sRN4 вот тут хороший практический пример по шагам с такой миграцией:

- создать новую колонку (пока без constraint, если они нужны). 
- накатываем новую версию кода. В ней пишем в обе колонки. Старая колонка при этом считается консистентной, поэтому читаем только с нее (либо же читаем сначала с новой, затем если она пустая, то используем значение из старой. В каких-то кейсах может быть оправдано)
- накатываем миграцию. Переносим значения их старой колонки в новую. Условно: UPDATE table SET new_col = old_col WHERE
 old_col IS NULL
- накатываем новую версию кода - в ней, читаем только из новой колонки
- удаляем старую колонку

Организация мерж реквестов для таких кейсов:
- разработчик готовит необходимое количество MR для кода приложения в мастер + необходимое кол-во MR
 для миграций в release-migrations
- такой тикет будет проходить цикл ревью, тестов и релизов такой количество раз, пока не выполнится последний шаг удаления старой колонки/таблицы/представления
- тикет не должен переносится в колонку релиз. Возможно, стоит для таких тикетов завести отдельную колонку (типа мульти-релиз). 
- Либо же, на этапе проектирования бить тикет так, чтобы он состоял из подтикетов, которые будут проходить обычный флоу релизов.

Пару моментов:
- NULL (NOT NULL) constraint. Если нужно добавить колонку с NOT NULL, то сначала добавляем ее с NULL
, и после того, как мы убедимся, что данные в ней полностью заполнены (после 4го шага в алгоритме выше), добавляем ALERT с NOT NULL. 
- стараться делать альтеры без лока таблиц. 
    - в кейсе добавления нового индекса, можно пойти след путем:
        - создать новую колонку с нужным индексом (т.к. колонка пустая, то индекс не залочит таблицу).
        - далее, все +- также как и с переименованием.
        
    - в кейсе добавления колонки с значением по умолчанию - приведет к локу таблицу. Вместо этого:
        - создаем колонку
        - в след миграции (или в этой же, но в другой транзакции) - добавляем альтер на DEFAULT value
        . Значение по умолчанию будет применяться для новых добавляемых колонок
        - если для старых значений необходимо также значение по умолчанию, отдельным скриптом проходим по всем старым записям и устанавливаем им значение по умолчанию.

    - для кейса с альтерами колонок, которые больше не используются (например с удалением тяжелой неиспользуемой колонки), можно заюзать неблокирующие альтеры https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl.html ALTER TABLE … ALGORITHM INPLACE LOCK NONE;

- удаление неиспользуемых колонок/схем должны релизиться после 1-2
 недель с релиза, когда был выпилен код, который зависел от этих схем. 
- работа с ORM должна быть в одном месте. Если работа с бд разбросана по всему коду, то править придется много больше
- поэтапные миграции могут приводить к увеличению занимаемого объема хранилища. Перед этим желательно оценить, готова ли
система к таким скачками. Возможно, нужно заранее реализовать механизм шардирования (вертикального/горизонтального)

Доп моменты:
- (опционально) Новые задачи в работу не берутся, пока не выполнятся все миграции (чтобы не создавать нагрузку на мигрирующиеся схемы бд). 
- старые воркеры при релизе продолжат свое выполнение (т.е. будут выполнятся уже взятые в работу задачи). 
Поэтому надо учитывать, что все миграции применяются на таблицы, на которых уже есть нагрузка. 
Т.е. желательно миграции вливать в моменты наименьшей активности 
- мониторить и дропать воркеры, которые выполняются больше адекватного времени (сутки и больше). Для начала можно собирать такой список
 воркеров и слать где-нибудь в телеге или иными средствами мониторинга  
